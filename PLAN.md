# Monorail: Project Plan

> Living document. Updated each session. Read this first.

---

## What Is Monorail?

An MCP tool that lets Claude and humans collaborate on presentation decks in Figma. Not "generate and export" â€” a live loop where both parties work in the same canvas.

**Named after:** Lyle Lanley's monorail pitch in The Simpsons â€” an argument so tight it sells the room.

---

## How We Build It: The Ralph Wiggum Approach

We use the **Ralph Wiggum methodology** for development:

- **Persistent Plan** â€” This document. Updated each session.
- **Clean Sessions** â€” One task per session with clear completion criteria.
- **Persistent Findings** â€” Learnings logged to `docs/failures.md`.
- **Iterative Loops** â€” Keep going until it works.

### The Meta-Connection

| Name | In the show | In our project |
|------|-------------|----------------|
| **Monorail** | The pitch that lands | The product â€” decks with narrative coherence |
| **Ralph Wiggum** | "I'm helping!" persistence | The methodology â€” iterative loops until done |

The product (Monorail) is about **iterative collaboration loops** between Claude and human.  
We build it using **iterative development loops** (Ralph Wiggum approach).  
It's loops all the way down. ðŸš

### Cursor Plans vs. Ralph Wiggum Docs

When working in Cursor, you have access to "Cursor plans" â€” a tool for tracking execution of a single task. Here's how they fit with our persistent docs:

| Artifact | Purpose | Lifespan | Location |
|----------|---------|----------|----------|
| **Cursor plan** | Execution tracking for a single task | One session | `~/.cursor/plans/` (ephemeral) |
| **PLAN.md** | Project state, session logs, what's next | Persistent | Workspace root |
| **docs/*.md** | Specs, decisions, reference material | Persistent | `docs/` |
| **failures.md** | Learnings, gotchas, things that didn't work | Persistent | `docs/failures.md` |

**When to use Cursor plans:**
- Task has 4+ implementation steps
- You want todo checkboxes that track progress
- The task is ambitious enough to benefit from structured tracking

**When NOT to use Cursor plans:**
- For design decisions â†’ put in `docs/decisions/`
- For session summaries â†’ put in `PLAN.md`
- For learnings/gotchas â†’ put in `docs/failures.md`

**At session end:** Cursor plan can be discarded. Anything worth keeping goes into the persistent docs.

---

## Current State

### What's Built âœ…

| Component | Status | Location |
|-----------|--------|----------|
| Architecture spec | Done | `docs/ARCHITECTURE.md` |
| Narrative toolkit (SKILL.md) | Done | `docs/SKILL.md` |
| IR format spec | Done | `docs/PLUGIN-SPEC.md` |
| Archetype definitions | Done | `docs/references/archetypes.md` |
| Critic heuristics | Done | `docs/references/critics.md` |
| **MCP server** | Done | `src/index.ts` |
| Demo deck + landing page | Done | `examples/` |
| **Figma plugin** | **Working!** | `figma-plugin/` |
| **HTML preview renderer** | Done | Generated by MCP |
| **Export IR** | **Working!** | `figma-plugin/code.ts` |
| **Apply to Deck** | **Working!** | `figma-plugin/code.ts` |

### What We've Learned ðŸ“

See `docs/failures.md` for details.

**Key findings:**
1. Figma MCP doesn't support Figma Slides (only Design, FigJam, Make)
2. Figma REST API is read-only for design content (can't create frames/text)
3. Write access requires Figma Plugin API (runs in Figma's sandbox)
4. Plugin workflow has friction (manual paste, session per task)
5. **Figma Slides API specifics:**
   - Use `figma.createSlide()` not `figma.createFrame()` for actual slides
   - Set `slide.fills = [{ type: 'SOLID', color }]` for backgrounds (not rectangles!)
   - With `documentAccess: dynamic-page`, use `getNodeByIdAsync()` not `getNodeById()`
   - Slide structure: Page â†’ SLIDE_GRID â†’ SLIDE_ROW â†’ SLIDE (need recursive traversal)

### What's Next ðŸ”¨

**v0 COMPLETE!** The full round-trip loop works:
1. Create slides in Figma (or Apply IR from Claude)
2. Edit in Figma â€” change text, rearrange, refine
3. Export as IR â€” plugin analyzes and extracts structure
4. Give IR to Claude â€” "tighten the bullets", "add a timeline slide"
5. Claude returns updated IR
6. Apply to Deck â€” updates existing, creates new, skips locked
7. Repeat until it lands

**Next steps (v1):**
- [x] **Freeform edit handling** â€” IMPLEMENTED âœ… (see `docs/decisions/freeform-handling.md`)
  - [x] Name text nodes on creation (`headline`, `bullet-0`, etc.)
  - [x] Update Apply to modify text in-place instead of re-rendering
  - [x] Update Export to capture `extras` (unrecognized text)
  - [x] Add `extras` field to IR schema
- [ ] **Delete slide capability** â€” plugin can only create/update, not delete
  - Add `monorail_delete_slides` MCP tool (takes array of slide IDs)
  - Plugin needs `delete-slides` message handler
  - Critical for cleaning up orphan slides after failed pushes
- [ ] **IR validation** â€” malformed IR crashes the plugin silently
  - Add JSON schema validation in `monorail_push_ir` before sending
  - Add `monorail://ir-schema` resource so Claude can reference the spec
  - Prevents bugs like flat vs nested content structure
- [ ] **Preserve Layout mode** â€” protect human formatting during iteration
  - Problem: Changing archetype triggers full re-render, destroying human polish
  - Solution: Add `preserveLayout: true` flag that ONLY updates text content
  - If archetype changed + preserveLayout: warn/fail instead of re-rendering
  - Use case: Human has perfected positioning, Claude just needs to tighten copy
  - Related: Consider separate "content-only" update vs "full re-render" tools
- [ ] **Figma Slides best practices** â€” current plugin uses raw absolute positioning
  - Current approach: `addText(parent, text, x, y, fontSize)` â€” simple but rigid
  - Figma Slides supports: Auto Layout, Grid systems, Components, Templates
  - Auto Layout: Text reflows when content length changes (avoids overflow)
  - Components: Reusable slide templates, update once â†’ updates everywhere
  - Future: Could generate slides as component instances, not raw nodes
  - Research: What's possible via Plugin API? Can we create Auto Layout frames?
- [ ] Improve archetype detection heuristics (edge cases)
- [ ] Handle mixed fonts / complex layouts gracefully
- [ ] Add deck title extraction from first slide
- [ ] Add `chart` and `timeline` archetype detection

**High-priority:**
- [x] **WebSocket bridge** â€” COMPLETE! âœ… (see `docs/decisions/websocket-bridge.md`)
  - âœ… `monorail_push_ir` and `monorail_pull_ir` tools working
  - âœ… Copy/paste-free workflow achieved
  - âœ… Documented local MCP decision (`docs/decisions/local-mcp.md`)

**Design decisions needed:**
- [ ] **Design co-creation: understanding the constraints** â€” NEXT STEP
  - **The asymmetry:** Claude is fluent in HTML/CSS, weak in Figma Plugin API
  - **Evidence:** HTML deck (`examples/monorail-deck-v0.html`) is beautiful â€” diagrams, callouts, styled Q&A, visual loops. Our Figma output is functional text dumps.
  - **The gap:** IR â†’ Plugin API loses Claude's design strength
  - **Before deciding architecture, research: what's actually possible?**
  - Next session task: **Figma Plugin API capabilities audit**
    - Can Plugin API create Auto Layout frames?
    - Can it create styled rectangles, borders, gradients?
    - Can it read/use template styles?
    - Can it create component instances?
    - What visual primitives are available beyond text nodes?
  - Then decide between:
    - **Enrich IR + Plugin** â€” express design in IR, build sophisticated renderer
    - **HTML-first workflow** â€” iterate in HTML, Figma for final
    - **Separation of concerns** â€” human designs templates, Claude fills content
    - **Teach Claude Figma** â€” add Plugin API patterns as resource
    - **HTML â†’ Figma bridge** â€” research if conversion tooling exists
  - Goal: Co-create design, not just content

- [ ] **Template integration strategy** â€” our archetypes bypass Figma's native template system
  - Current: Hardcoded colors, fonts, layouts in plugin code
  - Figma-native: Templates define colors, fonts, slide layouts that users pick from
  - Options to explore:
    - **A) Opinionated** â€” ship Monorail template, users install it, plugin uses it
    - **B) Adaptive** â€” read user's existing template, generate matching slides
    - **C) Hybrid** â€” ship default template, but detect/adapt to user's brand
  - Experiment with both to see what feels best
  - Key questions:
    - Can Plugin API read template styles? (colors, fonts)
    - Can we generate slides as template layout instances?
    - What's the onboarding like for each approach?
  - See: `docs/decisions/` for eventual write-up

**Documentation refresh:**
- [ ] **Update README.md** â€” currently stale, says "v0 under construction"
  - Update status to reflect v0 complete
  - Add WebSocket bridge section
  - Update project structure (no src/tools/)
  - Add "Quick Start" with actual working commands
- [ ] **Update landing page** â€” examples/index.html may need refreshing
  - Verify install commands are correct
  - Add any new features (WebSocket, etc.)
  - Consider adding demo GIF or video

**Discovery tasks:**
- [ ] **Visual feedback loop** â€” Claude is currently blind to rendered output!
  - Can't see: text overflow, overlapping elements, broken layouts
  - Options: Plugin exports screenshot, Figma REST API image export, HTML preview
  - Critical for Claude to self-correct visual issues
  - Research: Can Figma plugin export slide as image? Can Claude process it?
- [ ] **Event-driven updates** â€” decks that stay in sync with reality
  - Webhook triggers: project status, metrics, sprint completion
  - Agent updates specific slides without human intervention
  - Use case: "living deck" that reflects current state
  - Architecture: MCP server as webhook receiver? Scheduled refresh?

---

## Session Log

### Session 1 (2026-01-11)
**Task:** Set up workspace, explore Figma MCP capabilities, establish Ralph Wiggum workflow

**Completed:**
- âœ… Pulled monorail folder from Desktop, reorganized into proper project structure
- âœ… Created MCP server scaffold (`src/index.ts`) with 4 placeholder tools
- âœ… Set up TypeScript, dependencies, builds clean
- âœ… Explored Figma MCP â€” **discovered it doesn't support Figma Slides**
- âœ… Explored Figma REST API â€” **confirmed it's read-only for design content**
- âœ… Scaffolded Figma plugin (`figma-plugin/`) â€” compiles, has basic IRâ†’slides logic
- âœ… Set up Ralph Wiggum approach (PLAN.md, failures.md, clarified naming)

**Key findings logged to `docs/failures.md`:**
1. Figma MCP only supports Design/FigJam/Make, not Slides
2. REST API can't write design content â€” Plugin API required
3. Plugin workflow has friction (manual paste per iteration)

**Next session task:** 
> Test full loop with Figma plugin manually

---

### Session 2 (2026-01-11)
**Task:** Decide integration approach (A/B/C) and implement

**Decision:** Hybrid B+C
- **HTML preview** for instant feedback (fast iteration)
- **Figma plugin** for real output (when ready)
- Best of both: fast iteration AND real Figma slides

**Completed:**
- âœ… Implemented `monorail_validate_ir` â€” validates IR against archetype constraints
- âœ… Implemented `monorail_create_deck` â€” creates deck from IR JSON
- âœ… Implemented `monorail_update_slides` â€” updates non-locked slides
- âœ… Implemented `monorail_get_deck` â€” retrieves current IR
- âœ… Implemented `monorail_preview` â€” generates HTML preview file
- âœ… Built HTML preview renderer with all 10 archetypes
- âœ… Tested end-to-end: IR â†’ MCP â†’ HTML preview works!

**Figma plugin debugging:**
- âœ… Fixed `getNodeById` error â†’ use `getNodeByIdAsync` with `dynamic-page`
- âœ… Fixed white backgrounds â†’ use `slide.fills` not rectangles
- âœ… Fixed slide creation â†’ use `figma.createSlide()` for real slides
- âœ… Added all 10 archetypes with proper layout and colors

**The loop works:**
```
Claude generates IR â†’ monorail_create_deck â†’ monorail_preview â†’ preview.html
                                                                    â†“
                                                           Open in browser
                                                                    â†“
                                                        "Copy IR for Figma"
                                                                    â†“
                                                           Figma plugin
                                                                    â†“
                                                            Real slides
```

---

### Session 3 (2026-01-11)
**Task:** Complete the v0 loop â€” make Export IR actually work

**Completed:**
- âœ… Fixed slide traversal for Figma Slides (SLIDE_GRID â†’ SLIDE_ROW â†’ SLIDE)
- âœ… Implemented `analyzeSlideContent()` â€” detects archetypes from text layout
- âœ… Export correctly identifies: title, bullets, big-idea, two-column, quote, summary
- âœ… Content extraction works (headlines, sublines, bullets, columns, etc.)
- âœ… Added update-in-place logic to Apply (respects `status: locked`, updates existing slides)
- âœ… **Tested full round-trip: Export â†’ Claude â†’ Apply works!**

**The v0 loop is complete:**
```
Figma Slides                          Claude
     â”‚                                   â”‚
     â”œâ”€â”€â”€â”€ Export as IR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚     (analyzes slides,             â”‚
     â”‚      detects archetypes)          â”‚
     â”‚                                   â”‚
     â”‚                            Claude refines IR
     â”‚                            (tighten copy,
     â”‚                             add slides, etc.)
     â”‚                                   â”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€ Apply to Deck â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚     (creates new slides,          â”‚
     â”‚      updates existing,            â”‚
     â”‚      skips locked)                â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Sample export output:**
- Slide 1: `title` â†’ headline: "Monorail", subline: "Where AI helps..."
- Slide 2: `bullets` â†’ headline + 3 bullet items
- Slide 3: `big-idea` â†’ headline + subline
- Slide 4: `two-column` â†’ left/right with titles and bodies
- Slide 5: `quote` â†’ quote + attribution
- Slide 6: `summary` â†’ headline + items

---

### Session 4 (2026-01-11)
**Task:** Design freeform edit handling â€” what happens when humans add content outside archetypes?

**Design decision:** Update in place + Capture extras
- Apply should modify text nodes by name instead of re-rendering (preserves human formatting)
- Export should capture unrecognized text in an `extras` field (Claude sees everything)
- Full details: `docs/decisions/freeform-handling.md`

**Also decided:** How Cursor plans fit with Ralph Wiggum methodology
- Cursor plans = execution tracking for a single session (ephemeral)
- PLAN.md / docs/ = persistent context across sessions
- Added guidance to "How We Build It" section

**Completed:**
- âœ… Design decision for freeform handling (decided, documented)
- âœ… Created `docs/decisions/` folder for architectural decisions
- âœ… Documented Cursor plans vs. Ralph Wiggum docs integration
- âœ… Updated PLAN.md with session log and new structure

**Next session task:**
> Implement freeform edit handling â€” start with naming text nodes, then update-in-place Apply logic

---

### Session 5 (2026-01-11)
**Task:** Implement freeform edit handling

**Completed:**
- âœ… Added `nodeName` parameter to `addText()` function
- âœ… Updated all archetypes to name their text nodes (`headline`, `bullet-0`, `left-title`, etc.)
- âœ… Implemented `updateContentInPlace()` â€” updates `.characters` only, preserves formatting
- âœ… Implemented `detectExistingArchetype()` â€” identifies archetype from node names
- âœ… Modified Apply logic: same archetype â†’ in-place update; different â†’ re-render
- âœ… Updated Export to track "claimed" nodes and capture unclaimed text as `extras`
- âœ… Added `extras?: string[]` field to Slide interface
- âœ… **Tested full loop manually â€” it works!**

**Key behavior:**
- First Apply after upgrade: re-renders (old slides have no named nodes)
- Subsequent Applies: updates in-place (nodes now have names)
- Human additions (text outside archetype) captured in `extras`
- Human formatting (position, font, color changes) preserved on in-place update

**What's next:**
- Visual feedback loop (Claude can't see rendered output)
- WebSocket bridge (remove copy/paste friction)
- Edge case improvements (archetype detection, mixed fonts)

---

### Session 6 (2026-01-11)
**Task:** Design work â€” user consumption model, WebSocket bridge priority

**Key insight: Monorail is a collaboration relationship, not just tools**

The product isn't "tools Claude can use" â€” it's setting up a collaboration where Claude helps with:
1. **Setup** â€” install plugin, test workflow, confirm everything works
2. **Brief** â€” find the spine, work through the argument
3. **Build** â€” generate IR â†” edit in Figma â†” iterate
4. **Polish** â€” lock settled slides, fine-tune the rest

**WebSocket bridge is high priority** because it enables:
1. Copy/paste-free workflow (obvious UX win)
2. **Claude debugging the plugin** â€” development acceleration
3. The "Claude-assisted everything" model â€” setup, troubleshooting, iteration

With WebSocket, Claude can: send test IR, get logs, diagnose issues, retry â€” the plugin development itself becomes a collaboration loop.

**Completed:**
- âœ… Documented collaboration model insight
- âœ… Created `docs/decisions/websocket-bridge.md` with full design
- âœ… Identified research questions (Figma WebSocket support, protocol, security)
- âœ… Proposed MCP tools: `monorail_connection_status`, `monorail_push_ir`, `monorail_pull_ir`, `monorail_get_plugin_logs`
- âœ… Updated Next Session Prompt for WebSocket work

**Next session task:**
> Research and spike WebSocket bridge â€” can Figma plugin connect to localhost? Build minimal proof-of-concept.

---

### Session 7 (2026-01-11)
**Task:** WebSocket bridge spike â€” server side + plugin client

**Completed:**
- âœ… Added `ws` package to MCP server
- âœ… WebSocket server runs on `ws://localhost:9876` alongside stdio transport
- âœ… Hello/hello-ack handshake protocol implemented
- âœ… Plugin UI has WebSocket client (auto-connect, status indicator)
- âœ… Added `monorail_connection_status` MCP tool
- âœ… Tested server-side connection works with Node.js client

**Key findings:**
- WebSocket server works alongside MCP stdio â€” no conflicts
- Protocol is simple JSON messages with `type` field
- Server tracks connected plugin info (name, version, connected time)

**Tested in Figma â€” IT WORKS! âœ…**
- Plugin connects to `ws://localhost:9876` successfully
- Hello-ack handshake works
- UI shows green "Connected to MCP server" indicator
- Reconnection works (tested multiple connect/disconnect cycles)

**Next session task:**
> Implement `monorail_push_ir` and `monorail_pull_ir` tools for copy/paste-free workflow.

---

### Session 8 (2026-01-11)
**Task:** Implement WebSocket push/pull tools + refresh plugin UI

**Completed:**
- âœ… Implemented `monorail_push_ir` â€” pushes IR directly to plugin, optional auto-apply
- âœ… Implemented `monorail_pull_ir` â€” requests export, waits for response, returns IR
- âœ… Added WebSocket message handlers for `exported` and `applied` responses
- âœ… Added monorail to Cursor MCP config (`~/.cursor/mcp.json`)
- âœ… Created `docs/decisions/local-mcp.md` â€” documented why local > remote for this use case
- âœ… **Tested full round-trip: pull â†’ modify â†’ push works!**
- âœ… Refreshed plugin UI: activity feed + collapsible manual controls
- âœ… Made plugin window smaller (320Ã—280)

**Key findings:**
- Cursor starts MCP server as child process; WebSocket server runs alongside stdio
- If multiple MCP processes start, only one can bind port 9876 â€” can cause connection issues
- Plugin must reconnect when MCP server restarts
- Local MCP is the right architecture (privacy, latency, simplicity)
- Manual paste/export still useful as fallback, but collapsed since WebSocket is primary

**The copy/paste-free loop works:**
```
Claude                              Figma Plugin
   â”‚                                      â”‚
   â”œâ”€â”€â”€â”€ monorail_push_ir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ (auto-applies)
   â”‚                                      â”‚
   â”‚â—„â”€â”€â”€â”€ monorail_pull_ir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (exports & returns IR)
   â”‚                                      â”‚
```

---

### Session 9 (2026-01-11)
**Task:** Dog-food by making a deck about Monorail

**Completed:**
- âœ… Created 8-slide Monorail deck with Lyle Lanley energy
- âœ… Call-and-response slide (objections â†’ "Monorail!" answers)
- âœ… "Brain-dead slobs / cushy jobs" quote slide
- âœ… Found and fixed IR schema bug (flat vs nested `content`)
- âœ… Cleaned up orphan slides from failed push

**Bugs found & added to plan:**
- `monorail_delete_slides` tool needed â€” can't clean up orphans programmatically
- IR validation needed â€” malformed IR crashes plugin silently
- `preserveLayout` mode needed â€” archetype changes destroy human formatting

**Architecture insights discovered:**
1. **Figma Slides best practices** â€” we use raw absolute positioning, Figma supports Auto Layout, Components, Templates
2. **Template system bypass** â€” our archetypes are hardcoded, not connected to Figma's native template system
3. **Design co-creation gap** â€” HTML deck is beautiful (diagrams, callouts, styled Q&A), Figma output is functional text dumps
4. **The asymmetry** â€” Claude is fluent in HTML/CSS, weak in Figma Plugin API. We're routing through its weakest channel.

**Key insight:** Before deciding architecture, we need to understand what's actually possible with the Figma Plugin API.

**Commits:**
- `301c8f5` Add tasks from dog-fooding session
- `7bf4deb` Add Figma Slides learnings: preserveLayout feature
- `7c99ab6` Add template integration design decision
- `7984198` Add design co-creation investigation

**Next session task:**
> Figma Plugin API capabilities audit â€” what visual primitives can we actually create?

---

## Completion Criteria (v0)

The loop works end-to-end:
- [x] Claude generates IR from a brief
- [x] IR gets rendered visibly (HTML preview âœ…, Figma plugin âœ…)
- [x] Human can edit in Figma
- [x] Claude can see what changed (Export IR âœ…)
- [x] Claude adapts, regenerates
- [x] Repeat until deck lands

**ðŸŽ‰ v0 COMPLETE!** The full round-trip loop is working.

---

## Quick Reference

```
monorail-mcp/
â”œâ”€â”€ PLAN.md              # This file â€” read first
â”œâ”€â”€ README.md            # Public-facing docs
â”œâ”€â”€ src/                 # MCP server
â”œâ”€â”€ figma-plugin/        # Figma plugin
â”œâ”€â”€ docs/                # Specs and references
â”‚   â”œâ”€â”€ ARCHITECTURE.md
â”‚   â”œâ”€â”€ PLUGIN-SPEC.md
â”‚   â”œâ”€â”€ SKILL.md
â”‚   â”œâ”€â”€ failures.md      # Learnings log
â”‚   â”œâ”€â”€ decisions/       # Architectural decisions
â”‚   â”‚   â”œâ”€â”€ freeform-handling.md
â”‚   â”‚   â”œâ”€â”€ websocket-bridge.md
â”‚   â”‚   â””â”€â”€ local-mcp.md
â”‚   â””â”€â”€ references/
â””â”€â”€ examples/            # Demo content
```

---

## Next Session Prompt

Copy this to start your next session:

```
I'm working on Monorail â€” a tool for Claude + human collaboration on presentation decks via Figma.

**Read first:** `PLAN.md` in the workspace root.

---

## The Ralph Wiggum Method

We use this iterative development approach. Please follow it:

1. **Start by reading `PLAN.md`** â€” understand current state before touching code
2. **One focused task per session** â€” don't boil the ocean
3. **Log findings to `docs/failures.md`** â€” gotchas, API quirks, things that didn't work
4. **Update `PLAN.md` at session end** â€” add a session log entry with:
   - What task you worked on
   - What you completed (checkboxes)
   - What you learned
   - What's next
5. **Update the "Next Session Prompt"** â€” so the next Claude has fresh context

**Cursor plans:** Use them for ambitious tasks (4+ steps). They're ephemeral â€” anything worth keeping goes in PLAN.md or docs/. See "Cursor Plans vs. Ralph Wiggum Docs" in PLAN.md.

---

## Current State

**v0 loop is COMPLETE. WebSocket push/pull WORKING! âœ…**

The full collaboration loop works â€” **no copy/paste required:**
1. `monorail_pull_ir` â†’ Claude gets current deck from Figma
2. Claude refines the IR
3. `monorail_push_ir` â†’ sends updated IR directly to plugin (auto-applies)
4. Human edits in Figma (move, restyle, add content)
5. Repeat until deck lands

---

## WebSocket Bridge: FULLY WORKING âœ…

**MCP Tools:**
- `monorail_connection_status` â€” check if plugin connected
- `monorail_push_ir` â€” send IR to plugin (optional `autoApply`)
- `monorail_pull_ir` â€” request export, returns IR

**Setup:**
1. Monorail is configured in `~/.cursor/mcp.json`
2. Cursor auto-starts MCP server (which starts WebSocket on :9876)
3. Open Figma Slides â†’ run Monorail plugin â†’ auto-connects

**If connection issues:** Check for multiple MCP processes (`ps aux | grep monorail`). Only one can bind port 9876.

---

## Key Files

- `figma-plugin/code.ts` â€” the plugin (Apply + Export)
- `figma-plugin/ui.html` â€” plugin UI (activity feed + WebSocket client)
- `src/index.ts` â€” MCP server (WebSocket server + tools)
- `docs/decisions/websocket-bridge.md` â€” protocol design
- `docs/decisions/local-mcp.md` â€” why local not remote
- `docs/failures.md` â€” learnings and gotchas

---

## Next Session Task: Figma Plugin API Capabilities Audit

**Goal:** Understand what's actually possible with the Figma Plugin API before deciding architecture for design co-creation.

**Context from Session 9:**
- The HTML deck (`examples/monorail-deck-v0.html`) is beautiful â€” diagrams, callouts, styled Q&A, visual loops
- Our Figma output is functional text dumps
- **The asymmetry:** Claude is fluent in HTML/CSS, weak in Figma Plugin API
- We're routing through Claude's weakest channel

**Research questions:**
1. Can Plugin API create **Auto Layout frames**? (responsive spacing)
2. Can it create **styled rectangles** with borders, rounded corners, gradients?
3. Can it create **lines/arrows** for diagrams?
4. Can it read/apply **template styles**? (colors, fonts from user's template)
5. Can it create **component instances**? (use template layouts)
6. What **visual primitives** exist beyond text nodes and basic shapes?
7. Is there an **HTML â†’ Figma** conversion approach?

**How to approach this:**
1. Read Figma Plugin API docs (search web for current 2026 docs)
2. Experiment in `figma-plugin/code.ts` â€” try creating styled elements
3. Document findings in `docs/failures.md`
4. Update plan with architecture recommendation

**After this, decide between:**
- Enrich IR + Plugin (express design in IR)
- HTML-first workflow (iterate in HTML, Figma for final)
- Separation of concerns (human designs, Claude fills content)
- Teach Claude Figma (add Plugin API patterns as resource)
- HTML â†’ Figma bridge (if tooling exists)

---

## Open Discovery Tasks

For future sessions:

1. **Visual feedback loop** â€” Claude is currently blind to rendered output
   - Can't see: text overflow, overlapping elements, broken layouts
   - Options: Plugin exports screenshot, Figma REST API image export
   - Research: Can Figma plugin export slide as image? Can Claude process it?

2. **Event-driven updates** â€” decks that stay in sync with reality
   - Webhook triggers: project status, metrics, sprint completion
   - Agent updates specific slides without human intervention

3. **Polish tasks** â€” improve archetype detection, handle edge cases
```
