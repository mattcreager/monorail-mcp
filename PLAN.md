# Monorail: Project Plan

> Living document. Updated each session. Read this first.

---

## What Is Monorail?

An MCP tool that lets Claude and humans collaborate on presentation decks in Figma. Not "generate and export" â€” a live loop where both parties work in the same canvas.

**Named after:** Lyle Lanley's monorail pitch in The Simpsons â€” an argument so tight it sells the room.

---

## How We Build It: The Ralph Wiggum Approach

We use the **Ralph Wiggum methodology** for development:

- **Persistent Plan** â€” This document. Updated each session.
- **Clean Sessions** â€” One task per session with clear completion criteria.
- **Persistent Findings** â€” Learnings logged to `docs/failures.md`.
- **Iterative Loops** â€” Keep going until it works.

### The Meta-Connection

| Name | In the show | In our project |
|------|-------------|----------------|
| **Monorail** | The pitch that lands | The product â€” decks with narrative coherence |
| **Ralph Wiggum** | "I'm helping!" persistence | The methodology â€” iterative loops until done |

The product (Monorail) is about **iterative collaboration loops** between Claude and human.  
We build it using **iterative development loops** (Ralph Wiggum approach).  
It's loops all the way down. ğŸš

### Cursor Plans vs. Ralph Wiggum Docs

When working in Cursor, you have access to "Cursor plans" â€” a tool for tracking execution of a single task. Here's how they fit with our persistent docs:

| Artifact | Purpose | Lifespan | Location |
|----------|---------|----------|----------|
| **Cursor plan** | Execution tracking for a single task | One session | `~/.cursor/plans/` (ephemeral) |
| **PLAN.md** | Project state, session logs, what's next | Persistent | Workspace root |
| **docs/*.md** | Specs, decisions, reference material | Persistent | `docs/` |
| **failures.md** | Learnings, gotchas, things that didn't work | Persistent | `docs/failures.md` |

**When to use Cursor plans:**
- Task has 4+ implementation steps
- You want todo checkboxes that track progress
- The task is ambitious enough to benefit from structured tracking

**When NOT to use Cursor plans:**
- For design decisions â†’ put in `docs/decisions/`
- For session summaries â†’ put in `PLAN.md`
- For learnings/gotchas â†’ put in `docs/failures.md`

**At session end:** Cursor plan can be discarded. Anything worth keeping goes into the persistent docs.

---

## Current State

### What's Built âœ…

| Component | Status | Location |
|-----------|--------|----------|
| Architecture spec | Done | `docs/ARCHITECTURE.md` |
| Narrative toolkit (SKILL.md) | Done | `docs/SKILL.md` |
| IR format spec | Done | `docs/PLUGIN-SPEC.md` |
| Archetype definitions | Done | `docs/references/archetypes.md` |
| Critic heuristics | Done | `docs/references/critics.md` |
| **MCP server** | Done | `src/index.ts` |
| Demo deck + landing page | Done | `examples/` |
| **Figma plugin** | **Working!** | `figma-plugin/` |
| **HTML preview renderer** | Done | Generated by MCP |
| **Export IR** | **Working!** | `figma-plugin/code.ts` |
| **Apply to Deck** | **Working!** | `figma-plugin/code.ts` |

### What We've Learned ğŸ“

See `docs/failures.md` for details.

**Key findings:**
1. Figma MCP doesn't support Figma Slides (only Design, FigJam, Make)
2. Figma REST API is read-only for design content (can't create frames/text)
3. Write access requires Figma Plugin API (runs in Figma's sandbox)
4. Plugin workflow has friction (manual paste, session per task)
5. **Figma Slides API specifics:**
   - Use `figma.createSlide()` not `figma.createFrame()` for actual slides
   - Set `slide.fills = [{ type: 'SOLID', color }]` for backgrounds (not rectangles!)
   - With `documentAccess: dynamic-page`, use `getNodeByIdAsync()` not `getNodeById()`
   - Slide structure: Page â†’ SLIDE_GRID â†’ SLIDE_ROW â†’ SLIDE (need recursive traversal)

### What's Next ğŸ”¨

**v0 COMPLETE!** The full round-trip loop works:
1. Create slides in Figma (or Apply IR from Claude)
2. Edit in Figma â€” change text, rearrange, refine
3. Export as IR â€” plugin analyzes and extracts structure
4. Give IR to Claude â€” "tighten the bullets", "add a timeline slide"
5. Claude returns updated IR
6. Apply to Deck â€” updates existing, creates new, skips locked
7. Repeat until it lands

**Next steps (v1):**
- [x] **Freeform edit handling** â€” IMPLEMENTED âœ… (see `docs/decisions/freeform-handling.md`)
  - [x] Name text nodes on creation (`headline`, `bullet-0`, etc.)
  - [x] Update Apply to modify text in-place instead of re-rendering
  - [x] Update Export to capture `extras` (unrecognized text)
  - [x] Add `extras` field to IR schema
- [ ] **Delete slide capability** â€” plugin can only create/update, not delete
  - Add `monorail_delete_slides` MCP tool (takes array of slide IDs)
  - Plugin needs `delete-slides` message handler
  - Critical for cleaning up orphan slides after failed pushes
- [ ] **IR validation** â€” malformed IR crashes the plugin silently
  - Add JSON schema validation in `monorail_push_ir` before sending
  - Add `monorail://ir-schema` resource so Claude can reference the spec
  - Prevents bugs like flat vs nested content structure
- [ ] **Preserve Layout mode** â€” protect human formatting during iteration
  - Problem: Changing archetype triggers full re-render, destroying human polish
  - Solution: Add `preserveLayout: true` flag that ONLY updates text content
  - If archetype changed + preserveLayout: warn/fail instead of re-rendering
  - Use case: Human has perfected positioning, Claude just needs to tighten copy
  - Related: Consider separate "content-only" update vs "full re-render" tools
- [ ] **Figma Slides best practices** â€” current plugin uses raw absolute positioning
  - Current approach: `addText(parent, text, x, y, fontSize)` â€” simple but rigid
  - Figma Slides supports: Auto Layout, Grid systems, Components, Templates
  - Auto Layout: Text reflows when content length changes (avoids overflow)
  - Components: Reusable slide templates, update once â†’ updates everywhere
  - Future: Could generate slides as component instances, not raw nodes
  - Research: What's possible via Plugin API? Can we create Auto Layout frames?
- [ ] Improve archetype detection heuristics (edge cases)
- [ ] Handle mixed fonts / complex layouts gracefully
- [ ] Add deck title extraction from first slide
- [ ] Add `chart` and `timeline` archetype detection

**High-priority:**
- [x] **WebSocket bridge** â€” COMPLETE! âœ… (see `docs/decisions/websocket-bridge.md`)
  - âœ… `monorail_push_ir` and `monorail_pull_ir` tools working
  - âœ… Copy/paste-free workflow achieved
  - âœ… Documented local MCP decision (`docs/decisions/local-mcp.md`)

**Design co-creation: STRATEGY DEFINED âœ…** (See Session 10 + `docs/decisions/design-system-strategy.md`)

**The Vision: Two-Phase Collaboration**
1. **Sketch Phase** â€” Claude + human iterate on structure/argument. Visuals are rough.
2. **Production Phase** â€” "Make it match our design system." Claude reads system, applies it.

**Rich Read + Targeted Write: IMPLEMENTED âœ…** (Session 11)
- Export captures ALL elements with Figma node IDs
- `monorail_patch_elements` updates specific elements by ID
- Preserves layouts, diagrams, styling when editing text

**Implementation priorities (revised after Session 11):**

- [x] **Auto Layout archetypes** â€” DONE âœ…
- [x] **Rich Read** â€” DONE âœ… (recursive element capture)
- [x] **Targeted Write** â€” DONE âœ… (`monorail_patch_elements`)
- [ ] **Dynamic Templates** â€” HIGH PRIORITY (NEXT)
  - Current archetypes are hardcoded â€” need templates that live in Figma
  - Two use cases:
    1. **Extract template from existing slide** â€” "Learn slide-10's style"
    2. **Create new slides using template** â€” "Make SOLUTION slide like slide-10"
  - Implementation approach:
    - [ ] Read slide structure (frames, colors, spacing, hierarchy)
    - [ ] Identify template "slots" (section_label, headline, accent_block, etc.)
    - [ ] Store as reusable template spec
    - [ ] Instantiate template with new content
  - This unlocks: "Expand existing theme" workflow
- [ ] **Theme Generation** â€” AFTER TEMPLATES
  - Claude generates complete design system from scratch
  - Creates reference slides in Figma
  - Human refines, Claude learns
  - This unlocks: "Create new theme" workflow
- [ ] **Styled containers** â€” MEDIUM PRIORITY
  - Add `cornerRadius` to frames
  - Accent borders for callouts
- [ ] **SVG diagram support** â€” MEDIUM PRIORITY
  - Add `diagram?: string` field to IR
  - Claude generates diagrams as SVG

**Documentation refresh:**
- [ ] **Update README.md** â€” currently stale, says "v0 under construction"
  - Update status to reflect v0 complete
  - Add WebSocket bridge section
  - Update project structure (no src/tools/)
  - Add "Quick Start" with actual working commands
- [ ] **Update landing page** â€” examples/index.html may need refreshing
  - Verify install commands are correct
  - Add any new features (WebSocket, etc.)
  - Consider adding demo GIF or video

**Discovery tasks:**
- [ ] **Visual feedback loop** â€” Claude is currently blind to rendered output!
  - Can't see: text overflow, overlapping elements, broken layouts
  - Options: Plugin exports screenshot, Figma REST API image export, HTML preview
  - Critical for Claude to self-correct visual issues
  - Research: Can Figma plugin export slide as image? Can Claude process it?
- [ ] **Event-driven updates** â€” decks that stay in sync with reality
  - Webhook triggers: project status, metrics, sprint completion
  - Agent updates specific slides without human intervention
  - Use case: "living deck" that reflects current state
  - Architecture: MCP server as webhook receiver? Scheduled refresh?

---

## Session Log

### Session 1 (2026-01-11)
**Task:** Set up workspace, explore Figma MCP capabilities, establish Ralph Wiggum workflow

**Completed:**
- âœ… Pulled monorail folder from Desktop, reorganized into proper project structure
- âœ… Created MCP server scaffold (`src/index.ts`) with 4 placeholder tools
- âœ… Set up TypeScript, dependencies, builds clean
- âœ… Explored Figma MCP â€” **discovered it doesn't support Figma Slides**
- âœ… Explored Figma REST API â€” **confirmed it's read-only for design content**
- âœ… Scaffolded Figma plugin (`figma-plugin/`) â€” compiles, has basic IRâ†’slides logic
- âœ… Set up Ralph Wiggum approach (PLAN.md, failures.md, clarified naming)

**Key findings logged to `docs/failures.md`:**
1. Figma MCP only supports Design/FigJam/Make, not Slides
2. REST API can't write design content â€” Plugin API required
3. Plugin workflow has friction (manual paste per iteration)

**Next session task:** 
> Test full loop with Figma plugin manually

---

### Session 2 (2026-01-11)
**Task:** Decide integration approach (A/B/C) and implement

**Decision:** Hybrid B+C
- **HTML preview** for instant feedback (fast iteration)
- **Figma plugin** for real output (when ready)
- Best of both: fast iteration AND real Figma slides

**Completed:**
- âœ… Implemented `monorail_validate_ir` â€” validates IR against archetype constraints
- âœ… Implemented `monorail_create_deck` â€” creates deck from IR JSON
- âœ… Implemented `monorail_update_slides` â€” updates non-locked slides
- âœ… Implemented `monorail_get_deck` â€” retrieves current IR
- âœ… Implemented `monorail_preview` â€” generates HTML preview file
- âœ… Built HTML preview renderer with all 10 archetypes
- âœ… Tested end-to-end: IR â†’ MCP â†’ HTML preview works!

**Figma plugin debugging:**
- âœ… Fixed `getNodeById` error â†’ use `getNodeByIdAsync` with `dynamic-page`
- âœ… Fixed white backgrounds â†’ use `slide.fills` not rectangles
- âœ… Fixed slide creation â†’ use `figma.createSlide()` for real slides
- âœ… Added all 10 archetypes with proper layout and colors

**The loop works:**
```
Claude generates IR â†’ monorail_create_deck â†’ monorail_preview â†’ preview.html
                                                                    â†“
                                                           Open in browser
                                                                    â†“
                                                        "Copy IR for Figma"
                                                                    â†“
                                                           Figma plugin
                                                                    â†“
                                                            Real slides
```

---

### Session 3 (2026-01-11)
**Task:** Complete the v0 loop â€” make Export IR actually work

**Completed:**
- âœ… Fixed slide traversal for Figma Slides (SLIDE_GRID â†’ SLIDE_ROW â†’ SLIDE)
- âœ… Implemented `analyzeSlideContent()` â€” detects archetypes from text layout
- âœ… Export correctly identifies: title, bullets, big-idea, two-column, quote, summary
- âœ… Content extraction works (headlines, sublines, bullets, columns, etc.)
- âœ… Added update-in-place logic to Apply (respects `status: locked`, updates existing slides)
- âœ… **Tested full round-trip: Export â†’ Claude â†’ Apply works!**

**The v0 loop is complete:**
```
Figma Slides                          Claude
     â”‚                                   â”‚
     â”œâ”€â”€â”€â”€ Export as IR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚     (analyzes slides,             â”‚
     â”‚      detects archetypes)          â”‚
     â”‚                                   â”‚
     â”‚                            Claude refines IR
     â”‚                            (tighten copy,
     â”‚                             add slides, etc.)
     â”‚                                   â”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€ Apply to Deck â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚     (creates new slides,          â”‚
     â”‚      updates existing,            â”‚
     â”‚      skips locked)                â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Sample export output:**
- Slide 1: `title` â†’ headline: "Monorail", subline: "Where AI helps..."
- Slide 2: `bullets` â†’ headline + 3 bullet items
- Slide 3: `big-idea` â†’ headline + subline
- Slide 4: `two-column` â†’ left/right with titles and bodies
- Slide 5: `quote` â†’ quote + attribution
- Slide 6: `summary` â†’ headline + items

---

### Session 4 (2026-01-11)
**Task:** Design freeform edit handling â€” what happens when humans add content outside archetypes?

**Design decision:** Update in place + Capture extras
- Apply should modify text nodes by name instead of re-rendering (preserves human formatting)
- Export should capture unrecognized text in an `extras` field (Claude sees everything)
- Full details: `docs/decisions/freeform-handling.md`

**Also decided:** How Cursor plans fit with Ralph Wiggum methodology
- Cursor plans = execution tracking for a single session (ephemeral)
- PLAN.md / docs/ = persistent context across sessions
- Added guidance to "How We Build It" section

**Completed:**
- âœ… Design decision for freeform handling (decided, documented)
- âœ… Created `docs/decisions/` folder for architectural decisions
- âœ… Documented Cursor plans vs. Ralph Wiggum docs integration
- âœ… Updated PLAN.md with session log and new structure

**Next session task:**
> Implement freeform edit handling â€” start with naming text nodes, then update-in-place Apply logic

---

### Session 5 (2026-01-11)
**Task:** Implement freeform edit handling

**Completed:**
- âœ… Added `nodeName` parameter to `addText()` function
- âœ… Updated all archetypes to name their text nodes (`headline`, `bullet-0`, `left-title`, etc.)
- âœ… Implemented `updateContentInPlace()` â€” updates `.characters` only, preserves formatting
- âœ… Implemented `detectExistingArchetype()` â€” identifies archetype from node names
- âœ… Modified Apply logic: same archetype â†’ in-place update; different â†’ re-render
- âœ… Updated Export to track "claimed" nodes and capture unclaimed text as `extras`
- âœ… Added `extras?: string[]` field to Slide interface
- âœ… **Tested full loop manually â€” it works!**

**Key behavior:**
- First Apply after upgrade: re-renders (old slides have no named nodes)
- Subsequent Applies: updates in-place (nodes now have names)
- Human additions (text outside archetype) captured in `extras`
- Human formatting (position, font, color changes) preserved on in-place update

**What's next:**
- Visual feedback loop (Claude can't see rendered output)
- WebSocket bridge (remove copy/paste friction)
- Edge case improvements (archetype detection, mixed fonts)

---

### Session 6 (2026-01-11)
**Task:** Design work â€” user consumption model, WebSocket bridge priority

**Key insight: Monorail is a collaboration relationship, not just tools**

The product isn't "tools Claude can use" â€” it's setting up a collaboration where Claude helps with:
1. **Setup** â€” install plugin, test workflow, confirm everything works
2. **Brief** â€” find the spine, work through the argument
3. **Build** â€” generate IR â†” edit in Figma â†” iterate
4. **Polish** â€” lock settled slides, fine-tune the rest

**WebSocket bridge is high priority** because it enables:
1. Copy/paste-free workflow (obvious UX win)
2. **Claude debugging the plugin** â€” development acceleration
3. The "Claude-assisted everything" model â€” setup, troubleshooting, iteration

With WebSocket, Claude can: send test IR, get logs, diagnose issues, retry â€” the plugin development itself becomes a collaboration loop.

**Completed:**
- âœ… Documented collaboration model insight
- âœ… Created `docs/decisions/websocket-bridge.md` with full design
- âœ… Identified research questions (Figma WebSocket support, protocol, security)
- âœ… Proposed MCP tools: `monorail_connection_status`, `monorail_push_ir`, `monorail_pull_ir`, `monorail_get_plugin_logs`
- âœ… Updated Next Session Prompt for WebSocket work

**Next session task:**
> Research and spike WebSocket bridge â€” can Figma plugin connect to localhost? Build minimal proof-of-concept.

---

### Session 7 (2026-01-11)
**Task:** WebSocket bridge spike â€” server side + plugin client

**Completed:**
- âœ… Added `ws` package to MCP server
- âœ… WebSocket server runs on `ws://localhost:9876` alongside stdio transport
- âœ… Hello/hello-ack handshake protocol implemented
- âœ… Plugin UI has WebSocket client (auto-connect, status indicator)
- âœ… Added `monorail_connection_status` MCP tool
- âœ… Tested server-side connection works with Node.js client

**Key findings:**
- WebSocket server works alongside MCP stdio â€” no conflicts
- Protocol is simple JSON messages with `type` field
- Server tracks connected plugin info (name, version, connected time)

**Tested in Figma â€” IT WORKS! âœ…**
- Plugin connects to `ws://localhost:9876` successfully
- Hello-ack handshake works
- UI shows green "Connected to MCP server" indicator
- Reconnection works (tested multiple connect/disconnect cycles)

**Next session task:**
> Implement `monorail_push_ir` and `monorail_pull_ir` tools for copy/paste-free workflow.

---

### Session 8 (2026-01-11)
**Task:** Implement WebSocket push/pull tools + refresh plugin UI

**Completed:**
- âœ… Implemented `monorail_push_ir` â€” pushes IR directly to plugin, optional auto-apply
- âœ… Implemented `monorail_pull_ir` â€” requests export, waits for response, returns IR
- âœ… Added WebSocket message handlers for `exported` and `applied` responses
- âœ… Added monorail to Cursor MCP config (`~/.cursor/mcp.json`)
- âœ… Created `docs/decisions/local-mcp.md` â€” documented why local > remote for this use case
- âœ… **Tested full round-trip: pull â†’ modify â†’ push works!**
- âœ… Refreshed plugin UI: activity feed + collapsible manual controls
- âœ… Made plugin window smaller (320Ã—280)

**Key findings:**
- Cursor starts MCP server as child process; WebSocket server runs alongside stdio
- If multiple MCP processes start, only one can bind port 9876 â€” can cause connection issues
- Plugin must reconnect when MCP server restarts
- Local MCP is the right architecture (privacy, latency, simplicity)
- Manual paste/export still useful as fallback, but collapsed since WebSocket is primary

**The copy/paste-free loop works:**
```
Claude                              Figma Plugin
   â”‚                                      â”‚
   â”œâ”€â”€â”€â”€ monorail_push_ir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ (auto-applies)
   â”‚                                      â”‚
   â”‚â—„â”€â”€â”€â”€ monorail_pull_ir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (exports & returns IR)
   â”‚                                      â”‚
```

---

### Session 9 (2026-01-11)
**Task:** Dog-food by making a deck about Monorail

**Completed:**
- âœ… Created 8-slide Monorail deck with Lyle Lanley energy
- âœ… Call-and-response slide (objections â†’ "Monorail!" answers)
- âœ… "Brain-dead slobs / cushy jobs" quote slide
- âœ… Found and fixed IR schema bug (flat vs nested `content`)
- âœ… Cleaned up orphan slides from failed push

**Bugs found & added to plan:**
- `monorail_delete_slides` tool needed â€” can't clean up orphans programmatically
- IR validation needed â€” malformed IR crashes plugin silently
- `preserveLayout` mode needed â€” archetype changes destroy human formatting

**Architecture insights discovered:**
1. **Figma Slides best practices** â€” we use raw absolute positioning, Figma supports Auto Layout, Components, Templates
2. **Template system bypass** â€” our archetypes are hardcoded, not connected to Figma's native template system
3. **Design co-creation gap** â€” HTML deck is beautiful (diagrams, callouts, styled Q&A), Figma output is functional text dumps
4. **The asymmetry** â€” Claude is fluent in HTML/CSS, weak in Figma Plugin API. We're routing through its weakest channel.

**Key insight:** Before deciding architecture, we need to understand what's actually possible with the Figma Plugin API.

**Commits:**
- `301c8f5` Add tasks from dog-fooding session
- `7bf4deb` Add Figma Slides learnings: preserveLayout feature
- `7c99ab6` Add template integration design decision
- `7984198` Add design co-creation investigation

**Next session task:**
> Figma Plugin API capabilities audit â€” what visual primitives can we actually create?

---

### Session 10 (2026-01-11)
**Task:** Figma Plugin API Capabilities Audit + Design System Strategy

**Part 1: Plugin API Audit**

Key finding: The gap is USAGE, not capability! The API can do everything we need.

| Feature | API Support | Current Usage |
|---------|-------------|---------------|
| Auto Layout | âœ… `layoutMode`, `itemSpacing`, `padding*` | âŒ â†’ âœ… Implemented! |
| Gradients | âœ… `GRADIENT_LINEAR`, `gradientStops` | âŒ â†’ âœ… Implemented! |
| Rounded corners | âœ… `cornerRadius` | âŒ Not using |
| Lines + arrows | âœ… `createLine()` + `strokeCap = 'ARROW_LINES'` | âŒ Not using |
| SVG import | âœ… `createNodeFromSvg(svgString)` | âŒ Not using |
| Component instances | âœ… `component.createInstance()` | âŒ Not using |
| Read local styles | âœ… `getLocalPaintStylesAsync()` | âŒ Not using |

**Implemented this session:**
- âœ… `bullets` archetype now uses Auto Layout â€” text wraps properly!
- âœ… `title` archetype has gradient background
- âœ… Helper functions: `createAutoLayoutFrame()`, `addAutoLayoutText()`
- âœ… Tested in Figma Slides â€” works!

**Part 2: Design System Strategy Discussion**

Big insight from discussion: The real collaboration problem isn't "can the plugin do it" â€” it's "how does Claude know what to do?"

**Two-phase collaboration model:**
1. **Sketch phase** â€” Human + Claude iterate on structure/argument. Visuals are rough.
2. **Production phase** â€” "Make it consistent with our design system." Claude reads and applies the system.

**Design system sources (layered):**
1. **Bring your own** â€” User's work brand, conference theme. Claude learns from file/description/screenshot.
2. **Generate one** â€” Claude proposes based on content + best practice.
3. **Monorail default** â€” Reference implementation, also our lighthouse/dogfood.

**Key decision:** Build the Monorail Design System as proof of concept. If it works for us, it works for anyone.

**Documented in:** `docs/decisions/design-system-strategy.md`

**Late Session 10 insight: IR as Delta, not State**

The fidelity problem: IR captures content but loses visual state. Human edits in Figma, export is lossy, apply re-renders and destroys human work. Claude and human CONFLICT.

**Proposed evolution:**
- Current: IR = complete slide spec â†’ Plugin renders from scratch
- New: IR = delta/intent â†’ Plugin patches existing slides

Like Git commits vs full snapshots. Claude sends changes, not complete states. Human edits persist.

**This requires visual feedback** â€” Claude needs to SEE the slide to know what's there before suggesting changes.

**Hybrid model likely:**
- State-based IR for NEW slides (need full spec)
- Delta-based IR for UPDATES (preserve human work)

This might be the key to making Claude and human truly collaborate instead of conflict.

**Breakthrough: Intent-Based Collaboration**

Tested with a real complex slide (company deck). Screenshot showed: section label, headline, 3 accent blocks, complex diagram. IR captured: just headline, `archetype: unknown`. Massive fidelity loss.

**The reframe:** It's not "export/import" â€” it's Claude READING and WRITING.

**Core principle:** Claude works in INTENT/CONTENT, system handles RENDERING.

| Mode | Claude provides | System does |
|------|-----------------|-------------|
| Modify | "Change headline to X" | Patch in place |
| Create | "Slide about X with 3 points" | Use design system to render |

**Design system = the "how" layer.** Claude says WHAT, system determines HOW.

This unifies:
- Existing slide modification (Claude reads, suggests changes, system patches)
- New slide creation (Claude expresses intent, system renders with templates)
- Human work preservation (deltas don't destroy what Claude can't capture)

**Evolution: Scoped Context (efficiency insight)**

Context is expensive. Don't exchange what you don't need.

| Scope | What Claude reads | When to use |
|-------|-------------------|-------------|
| `copy` | Element IDs + text only | Wordsmithing, copy iteration |
| `structure` | + positions, hierarchy, diagram flags | Understanding layout |
| `full` | + fonts, colors, styles | Design/style changes |

Claude specifies what it needs: `monorail_pull({ detail: 'copy' })`
Claude specifies what it writes: `monorail_patch({ changes: [...] })`

**Already partially implemented:** `patch-elements` in plugin handles targeted writes.
**To add:** Scoped `detail` parameter on pull, `monorail_patch` MCP tool.

See `docs/decisions/design-system-strategy.md` for full sketch.

---

### Session 11 (2026-01-11)
**Task:** Implement Rich Read + Targeted Write (Intent-Based Collaboration)

**Breakthrough: Full element visibility achieved!**

Before this session, exporting slide-10 (complex company slide) returned:
```json
{ "archetype": "unknown", "content": { "headline": "Traditional access..." } }
```

After this session:
```json
{
  "archetype": "unknown",
  "has_diagram": true,
  "elements": [
    { "id": "9:141", "type": "body_text", "text": "challenge+solution" },
    { "id": "9:139", "type": "body_text", "text": "Traditional access..." },
    { "id": "9:144", "type": "accent_text", "text": "Give agents broad access..." },
    { "id": "9:147", "type": "accent_text", "text": "Limit agent capabilities..." },
    { "id": "9:150", "type": "accent_text", "text": "Build custom access controls..." },
    // ... 20+ diagram elements with IDs
  ]
}
```

**Implemented:**
- âœ… `getAllTextNodes()` â€” recursive finder, captures ALL text regardless of nesting
- âœ… `classifyElement()` â€” identifies type: `headline`, `accent_text`, `diagram_text`, `bullet`, etc.
- âœ… `buildElementInfos()` â€” converts to rich element array with Figma node IDs
- âœ… `has_diagram` flag â€” true when deeply nested content detected
- âœ… `monorail_patch_elements` MCP tool â€” update specific elements by ID
- âœ… `patch-elements` plugin handler â€” finds node by ID, updates text only
- âœ… WebSocket protocol for patch requests/responses

**Tested and working:**
```
Claude: monorail_patch_elements({ patches: { changes: [
  { target: "9:144", text: "Give agents broad access â†’ accept massive security risks. ğŸ”“" },
  { target: "9:147", text: "Limit capabilities â†’ sacrifice business value. ğŸ“‰" }
]}})

Result: âœ“ Patched 2 elements
```

Diagram, layout, colors, fonts â€” all preserved. Only text changed.

**The gap we hit: New slide creation doesn't match existing styles**

Created a new "SOLUTION" slide to follow slide-10's "CHALLENGE" slide:
- Content was correct (headline + 3 bullets)
- Styling was Monorail default, NOT slide-10's custom style
- Missing: section label, accent blocks with colored borders, layout

**This reveals the next architecture need: Dynamic Templates**

| Use Case | Example | What's Needed |
|----------|---------|---------------|
| **Expand existing theme** | "Add SOLUTION slide matching slide-10" | Learn template from example |
| **Create new theme** | "Build me a Monorail design system" | Generate templates from scratch |

Current archetypes are hardcoded in plugin. Need:
1. **Templates live in Figma** (not in code)
2. **Claude can read them** (extract structure, colors, spacing)
3. **Claude can instantiate them** (create new slides using template)

**Key insight:** Two distinct workflows:
- **Template extraction**: Read existing styled slide â†’ extract reusable template
- **Template instantiation**: Apply template to new content

---

## Completion Criteria (v0)

The loop works end-to-end:
- [x] Claude generates IR from a brief
- [x] IR gets rendered visibly (HTML preview âœ…, Figma plugin âœ…)
- [x] Human can edit in Figma
- [x] Claude can see what changed (Export IR âœ…)
- [x] Claude adapts, regenerates
- [x] Repeat until deck lands

**ğŸ‰ v0 COMPLETE!** The full round-trip loop is working.

---

## Quick Reference

```
monorail-mcp/
â”œâ”€â”€ PLAN.md              # This file â€” read first
â”œâ”€â”€ README.md            # Public-facing docs
â”œâ”€â”€ src/                 # MCP server
â”œâ”€â”€ figma-plugin/        # Figma plugin
â”œâ”€â”€ docs/                # Specs and references
â”‚   â”œâ”€â”€ ARCHITECTURE.md
â”‚   â”œâ”€â”€ PLUGIN-SPEC.md
â”‚   â”œâ”€â”€ SKILL.md
â”‚   â”œâ”€â”€ failures.md      # Learnings log
â”‚   â”œâ”€â”€ decisions/       # Architectural decisions
â”‚   â”‚   â”œâ”€â”€ freeform-handling.md
â”‚   â”‚   â”œâ”€â”€ websocket-bridge.md
â”‚   â”‚   â””â”€â”€ local-mcp.md
â”‚   â””â”€â”€ references/
â””â”€â”€ examples/            # Demo content
```

---

## Next Session Prompt

Copy this to start your next session:

```
I'm working on Monorail â€” a tool for Claude + human collaboration on presentation decks via Figma.

**Read first:** `PLAN.md` in the workspace root.

---

## The Ralph Wiggum Method

We use this iterative development approach. Please follow it:

1. **Start by reading `PLAN.md`** â€” understand current state before touching code
2. **One focused task per session** â€” don't boil the ocean
3. **Log findings to `docs/failures.md`** â€” gotchas, API quirks, things that didn't work
4. **Update `PLAN.md` at session end** â€” add a session log entry with:
   - What task you worked on
   - What you completed (checkboxes)
   - What you learned
   - What's next
5. **Update the "Next Session Prompt"** â€” so the next Claude has fresh context

**Cursor plans:** Use them for ambitious tasks (4+ steps). They're ephemeral â€” anything worth keeping goes in PLAN.md or docs/. See "Cursor Plans vs. Ralph Wiggum Docs" in PLAN.md.

---

## Current State (after Session 11)

**Rich Read + Targeted Write: WORKING! âœ…**

I can now:
1. `monorail_pull_ir` â†’ See ALL elements on complex slides (not just headlines)
2. `monorail_patch_elements` â†’ Update specific elements by Figma node ID
3. Preserve diagrams, layouts, styling when editing text

**The gap we hit:** Creating NEW slides doesn't match existing custom styles.

Test: Created "SOLUTION" slide to follow "CHALLENGE" slide (slide-10)
- Content was correct
- Styling was Monorail default, NOT slide-10's custom style
- Missing: section labels, accent blocks, matching layout

---

## MCP Tools Available

- `monorail_connection_status` â€” check if plugin connected
- `monorail_push_ir` â€” send IR to plugin (optional `autoApply`)
- `monorail_pull_ir` â€” request export, returns IR with full `elements` array
- `monorail_patch_elements` â€” update specific elements by Figma node ID

---

## Key Files

- `figma-plugin/code.ts` â€” plugin with rich export + patch support
- `src/index.ts` â€” MCP server with all tools
- `docs/decisions/design-system-strategy.md` â€” design system vision

---

## Next Session Task: Dynamic Templates

**Goal:** Enable "make a slide that matches this existing style"

**The problem:**
Current archetypes (title, bullets, etc.) are hardcoded in plugin code.
Can't create new slides that match custom styles (like slide-10's accent blocks).

**Two use cases to enable:**

1. **Expand existing theme** â€” "Add SOLUTION slide matching slide-10"
   - Read slide-10's structure (frames, colors, positions)
   - Extract as reusable template
   - Instantiate with new content

2. **Create new theme** â€” "Build me a design system"
   - Claude generates design spec
   - Renders reference slides
   - Human refines
   - Extract as templates

**Proposed approach:**

Step 1: Template Extraction
- Read slide structure (not just text â€” frames, colors, fills, strokes)
- Identify "slots" (section_label, headline, accent_block, etc.)
- Store as template spec

Step 2: Template Instantiation  
- Take template + content
- Create new slide with matching structure
- Fill slots with new content

**Key questions to answer:**
- How do we identify which frames are "slots" vs decoration?
- How do we handle variable-count elements (3 accent blocks vs 5)?
- Where do templates live? (Figma components? JSON specs? Both?)

**Test case:** 
- Extract template from slide-10 (CHALLENGE+SOLUTION style)
- Create slide-11 using that template with SOLUTION content
- Result should visually match slide-10's style

---

## Open Discovery Tasks

For future sessions:

1. **Visual feedback loop** â€” Claude is currently blind to rendered output
   - Can't see: text overflow, overlapping elements, broken layouts
   - Options: Plugin exports screenshot, Figma REST API image export
   - Research: Can Figma plugin export slide as image? Can Claude process it?

2. **Event-driven updates** â€” decks that stay in sync with reality
   - Webhook triggers: project status, metrics, sprint completion
   - Agent updates specific slides without human intervention

3. **Polish tasks** â€” improve archetype detection, handle edge cases

---

## Plugin API Quick Reference (from Session 10 audit)

**Auto Layout:**
```typescript
frame.layoutMode = 'VERTICAL' | 'HORIZONTAL';
frame.primaryAxisSizingMode = 'AUTO';
frame.counterAxisSizingMode = 'AUTO';
frame.paddingTop = frame.paddingBottom = 10;
frame.itemSpacing = 24;
```

**Styled rectangles:**
```typescript
rect.cornerRadius = 8;  // or individual: topLeftRadius, etc.
rect.fills = [{ type: 'SOLID', color: {...} }];
rect.strokes = [{ type: 'SOLID', color: {...} }];
rect.strokeWeight = 2;
```

**Gradient fills:**
```typescript
rect.fills = [{
  type: 'GRADIENT_LINEAR',
  gradientStops: [
    { position: 0, color: { r: 0.06, g: 0.06, b: 0.1 } },
    { position: 1, color: { r: 0.1, g: 0.1, b: 0.18 } }
  ],
  gradientTransform: [[1, 0, 0], [0, 1, 0]]
}];
```

**Lines with arrows:**
```typescript
const line = figma.createLine();
line.strokeCap = 'ARROW_LINES';  // adds arrowheads!
```

**SVG import:**
```typescript
const node = figma.createNodeFromSvg('<svg>...</svg>');
```

**Read local styles:**
```typescript
const paintStyles = await figma.getLocalPaintStylesAsync();
const textStyles = await figma.getLocalTextStylesAsync();
```
```
